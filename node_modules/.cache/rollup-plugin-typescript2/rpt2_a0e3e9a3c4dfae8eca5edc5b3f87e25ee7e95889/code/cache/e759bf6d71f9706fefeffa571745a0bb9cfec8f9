{"code":"import { isObject } from \"../shared/index\";\r\nimport { mutableHandlers } from \"./baseHandler\";\r\nexport function reactive(target) {\r\n    // 需要把目标变为响应式对象，Proxy\r\n    return createReactiveObject(target, mutableHandlers);\r\n}\r\nvar proxyMap = new WeakMap();\r\n// 核心操作就是读取文件的时候做依赖收集。 数据变化的时候重新执行effect\r\nfunction createReactiveObject(target, baseHandlers) {\r\n    // 如果不是对象， 直接返回\r\n    if (!isObject(target)) {\r\n        return target;\r\n    }\r\n    var existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // 只对对外称对象做代理， 默认不会递归， 而且不会重写对象中的属性\r\n    var proxy = new Proxy(target, baseHandlers);\r\n    // 将代理的对象和代理后的结果做一个映射表\r\n    proxyMap.set(target, proxy);\r\n    // 如果是对象， 返回被代理的对象\r\n    return proxy;\r\n}\r\n//# sourceMappingURL=reactive.js.map","references":["/Users/yueqi/Desktop/code/vue3-source/src/shared/index.ts","/Users/yueqi/Desktop/code/vue3-source/src/reactivity/baseHandler.ts"],"map":"{\"version\":3,\"file\":\"reactive.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/reactivity/reactive.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,iBAAiB,CAAA;AAC1C,OAAO,EAAE,eAAe,EAAE,MAAM,eAAe,CAAC;AAKhD,MAAM,UAAU,QAAQ,CAAC,MAAM;IAC3B,qBAAqB;IACrB,OAAO,oBAAoB,CAAC,MAAM,EAAE,eAAe,CAAC,CAAA;AACxD,CAAC;AAED,IAAM,QAAQ,GAAG,IAAI,OAAO,EAAE,CAAC;AAC/B,wCAAwC;AACxC,SAAS,oBAAoB,CAAC,MAAM,EAAE,YAAY;IAC9C,eAAe;IACf,IAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;QAClB,OAAO,MAAM,CAAA;KAChB;IAED,IAAM,aAAa,GAAG,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IAE3C,IAAG,aAAa,EAAE;QACd,OAAO,aAAa,CAAA;KACvB;IAED,mCAAmC;IACnC,IAAM,KAAK,GAAG,IAAI,KAAK,CAAC,MAAM,EAAE,YAAY,CAAC,CAAA;IAE7C,sBAAsB;IACtB,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IAE5B,kBAAkB;IAClB,OAAO,KAAK,CAAA;AAChB,CAAC\"}"}
